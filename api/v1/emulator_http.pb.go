// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.0
// - protoc             v3.12.4
// source: emulator.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationEmulatorListEmulator = "/v1.Emulator/ListEmulator"
const OperationEmulatorListEmulatorType = "/v1.Emulator/ListEmulatorType"
const OperationEmulatorListGame = "/v1.Emulator/ListGame"
const OperationEmulatorUpdateEmulator = "/v1.Emulator/UpdateEmulator"

type EmulatorHTTPServer interface {
	ListEmulator(context.Context, *ListEmulatorRequest) (*ListEmulatorResponse, error)
	ListEmulatorType(context.Context, *ListEmulatorTypeRequest) (*ListEmulatorTypeResponse, error)
	ListGame(context.Context, *ListGameRequest) (*ListGameResponse, error)
	UpdateEmulator(context.Context, *UpdateEmulatorRequest) (*UpdateEmulatorResponse, error)
}

func RegisterEmulatorHTTPServer(s *http.Server, srv EmulatorHTTPServer) {
	r := s.Route("/")
	r.GET("/api/v1/emulator", _Emulator_ListEmulator0_HTTP_Handler(srv))
	r.GET("/api/v1/game", _Emulator_ListGame0_HTTP_Handler(srv))
	r.GET("/api/v1/emulator/type", _Emulator_ListEmulatorType0_HTTP_Handler(srv))
	r.PUT("/api/v1/emulator", _Emulator_UpdateEmulator0_HTTP_Handler(srv))
}

func _Emulator_ListEmulator0_HTTP_Handler(srv EmulatorHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListEmulatorRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmulatorListEmulator)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListEmulator(ctx, req.(*ListEmulatorRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListEmulatorResponse)
		return ctx.Result(200, reply)
	}
}

func _Emulator_ListGame0_HTTP_Handler(srv EmulatorHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListGameRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmulatorListGame)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListGame(ctx, req.(*ListGameRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListGameResponse)
		return ctx.Result(200, reply)
	}
}

func _Emulator_ListEmulatorType0_HTTP_Handler(srv EmulatorHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListEmulatorTypeRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmulatorListEmulatorType)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListEmulatorType(ctx, req.(*ListEmulatorTypeRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListEmulatorTypeResponse)
		return ctx.Result(200, reply)
	}
}

func _Emulator_UpdateEmulator0_HTTP_Handler(srv EmulatorHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateEmulatorRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationEmulatorUpdateEmulator)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateEmulator(ctx, req.(*UpdateEmulatorRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateEmulatorResponse)
		return ctx.Result(200, reply)
	}
}

type EmulatorHTTPClient interface {
	ListEmulator(ctx context.Context, req *ListEmulatorRequest, opts ...http.CallOption) (rsp *ListEmulatorResponse, err error)
	ListEmulatorType(ctx context.Context, req *ListEmulatorTypeRequest, opts ...http.CallOption) (rsp *ListEmulatorTypeResponse, err error)
	ListGame(ctx context.Context, req *ListGameRequest, opts ...http.CallOption) (rsp *ListGameResponse, err error)
	UpdateEmulator(ctx context.Context, req *UpdateEmulatorRequest, opts ...http.CallOption) (rsp *UpdateEmulatorResponse, err error)
}

type EmulatorHTTPClientImpl struct {
	cc *http.Client
}

func NewEmulatorHTTPClient(client *http.Client) EmulatorHTTPClient {
	return &EmulatorHTTPClientImpl{client}
}

func (c *EmulatorHTTPClientImpl) ListEmulator(ctx context.Context, in *ListEmulatorRequest, opts ...http.CallOption) (*ListEmulatorResponse, error) {
	var out ListEmulatorResponse
	pattern := "/api/v1/emulator"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEmulatorListEmulator))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EmulatorHTTPClientImpl) ListEmulatorType(ctx context.Context, in *ListEmulatorTypeRequest, opts ...http.CallOption) (*ListEmulatorTypeResponse, error) {
	var out ListEmulatorTypeResponse
	pattern := "/api/v1/emulator/type"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEmulatorListEmulatorType))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EmulatorHTTPClientImpl) ListGame(ctx context.Context, in *ListGameRequest, opts ...http.CallOption) (*ListGameResponse, error) {
	var out ListGameResponse
	pattern := "/api/v1/game"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationEmulatorListGame))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *EmulatorHTTPClientImpl) UpdateEmulator(ctx context.Context, in *UpdateEmulatorRequest, opts ...http.CallOption) (*UpdateEmulatorResponse, error) {
	var out UpdateEmulatorResponse
	pattern := "/api/v1/emulator"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationEmulatorUpdateEmulator))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
